import { TranscriptLine, ActionItem } from './database'

interface GeminiGenerationOptions {
  transcript: TranscriptLine[]
  globalContext: string
  meetingContext: string
  notes: string
  existingTitle: string
}

interface GeminiGenerationResult {
  success: boolean
  data?: {
    summary: string
    actionItems: ActionItem[]
    description: string
    tags: string[]
  }
  error?: string
}

interface GeminiMessageOptions {
  type: 'slack' | 'email'
  data: {
    globalContext: string
    meetingContext: string
    title?: string
    description?: string
    notes?: string
    summary?: string
    transcript?: string
    actionItems?: ActionItem[]
    questionHistory?: { question: string; answer: string }[]
    followupQuestions?: string[]
    followupRisks?: string[]
    followupComments?: string[]
  }
  model?: string
}

interface FollowupQuestionsOptions {
  transcript: TranscriptLine[]
  title?: string
  description?: string
  context?: string
  notes?: string
  summary?: string
}

interface FollowupQuestionsResult {
  success: boolean
  data?: {
    questions: string[]
    risks: string[]
    comments: string[]
  }
  error?: string
}

interface AskQuestionOptions {
  question: string
  transcript: TranscriptLine[]
  title?: string
  description?: string
  context?: string
  notes?: string
  summary?: string
}

interface AskQuestionResult {
  success: boolean
  answer?: string
  error?: string
}

class GeminiService {
  private apiKey: string | null = null

  setApiKey(apiKey: string): void {
    this.apiKey = apiKey || process.env.GEMINI_API_KEY || null
  }

  private async makeGeminiRequest(prompt: string, model: string = 'gemini-2.5-pro-preview-06-05'): Promise<{ success: boolean; content?: string; error?: string }> {
    if (!this.apiKey) {
      return { success: false, error: 'Gemini API key not configured' }
    }

    try {
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [
            {
              parts: [
                {
                  text: prompt
                }
              ]
            }
          ],
          generationConfig: {
            temperature: 0.3,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 2048,
          }
        })
      })

      if (!response.ok) {
        const errorData = await response.text()
        return { success: false, error: `Gemini API error: ${response.status} - ${errorData}` }
      }

      const data = await response.json()
      
      if (data.candidates && data.candidates.length > 0 && data.candidates[0].content) {
        const content = data.candidates[0].content.parts[0].text
        return { success: true, content }
      } else {
        return { success: false, error: 'No content generated by Gemini' }
      }
    } catch (error) {
      return { success: false, error: `Network error: ${error instanceof Error ? error.message : 'Unknown error'}` }
    }
  }

  async generateMeetingContent(options: GeminiGenerationOptions): Promise<GeminiGenerationResult> {
    try {
      // Prepare transcript text
      const transcriptText = options.transcript
        .map(line => `[${line.time}] ${line.text}`)
        .join('\n')

      const prompt = `You are an AI assistant helping to analyze a meeting recording. Please generate a comprehensive analysis based on the following information:

MEETING CONTEXT:
Title: ${options.existingTitle}
Global Context: ${options.globalContext}
Meeting-Specific Context: ${options.meetingContext}

TRANSCRIPT:
${transcriptText}

NOTES:
${options.notes}

Please provide your response in the following JSON format (ensure it's valid JSON with escaped quotes):
{
  "summary": "A concise 2-3 sentence summary of the meeting's main points and outcomes",
  "description": "A more detailed description of what was discussed and accomplished (2-3 paragraphs)",
  "actionItems": [
    {
      "id": 1,
      "text": "Action item description",
      "completed": false
    }
  ],
  "tags": ["tag1", "tag2", "tag3"]
}

Guidelines:
- Summary: Keep it concise but capture the essence of the meeting
- Description: Provide context about the meeting type, participants, and key discussions
- Action Items: Extract clear, actionable tasks mentioned or implied in the discussion
- Tags: Generate 3-5 relevant tags for categorization (lowercase, single words or short phrases)
- Ensure the JSON is properly formatted and escaped`

      const result = await this.makeGeminiRequest(prompt)
      
      if (!result.success || !result.content) {
        return { success: false, error: result.error || 'Failed to generate content' }
      }

      try {
        // Try to extract JSON from the response
        const jsonMatch = result.content.match(/\{[\s\S]*\}/)
        if (!jsonMatch) {
          return { success: false, error: 'No valid JSON found in Gemini response' }
        }

        const parsedData = JSON.parse(jsonMatch[0])
        
        // Validate the structure
        if (!parsedData.summary || !parsedData.description || !parsedData.actionItems || !parsedData.tags) {
          return { success: false, error: 'Invalid response structure from Gemini' }
        }

        // Ensure action items have proper IDs
        const actionItems: ActionItem[] = parsedData.actionItems.map((item: any, index: number) => ({
          id: item.id || Date.now() + index,
          text: item.text || '',
          completed: item.completed || false
        }))

        return {
          success: true,
          data: {
            summary: parsedData.summary,
            description: parsedData.description,
            actionItems,
            tags: Array.isArray(parsedData.tags) ? parsedData.tags : []
          }
        }
      } catch (parseError) {
        return { success: false, error: `Failed to parse Gemini response: ${parseError instanceof Error ? parseError.message : 'Unknown error'}` }
      }
    } catch (error) {
      return { success: false, error: `Generation failed: ${error instanceof Error ? error.message : 'Unknown error'}` }
    }
  }

  async generateSummaryOnly(options: GeminiGenerationOptions): Promise<{ success: boolean; summary?: string; error?: string }> {
    try {
      const transcriptText = options.transcript
        .map(line => `[${line.time}] ${line.text}`)
        .join('\n')

      const prompt = `Please provide a concise 2-3 sentence summary of this meeting:

CONTEXT: ${options.globalContext}
MEETING CONTEXT: ${options.meetingContext}
TRANSCRIPT:
${transcriptText}
NOTES:
${options.notes}

Please respond with only the summary, no additional formatting or explanations.`

      const result = await this.makeGeminiRequest(prompt)
      
      if (!result.success || !result.content) {
        return { success: false, error: result.error || 'Failed to generate summary' }
      }

      return { success: true, summary: result.content.trim() }
    } catch (error) {
      return { success: false, error: `Summary generation failed: ${error instanceof Error ? error.message : 'Unknown error'}` }
    }
  }

  async generateMessage(options: GeminiMessageOptions): Promise<{ success: boolean; message?: string; error?: string }> {
    try {
      const { type, data } = options
      const model = options.model || 'gemini-2.5-pro-preview-06-05'

      // Build the context sections that are provided
      const contextSections: string[] = []
      
      if (data.globalContext) {
        contextSections.push(`GLOBAL CONTEXT:\n${data.globalContext}`)
      }
      
      if (data.meetingContext) {
        contextSections.push(`MEETING CONTEXT:\n${data.meetingContext}`)
      }
      
      if (data.title) {
        contextSections.push(`TITLE:\n${data.title}`)
      }
      
      if (data.description) {
        contextSections.push(`DESCRIPTION:\n${data.description}`)
      }
      
      if (data.summary) {
        contextSections.push(`SUMMARY:\n${data.summary}`)
      }
      
      if (data.notes) {
        contextSections.push(`NOTES:\n${data.notes}`)
      }
      
      if (data.transcript) {
        contextSections.push(`TRANSCRIPT:\n${data.transcript}`)
      }

      // Add action items if provided
      if (data.actionItems && data.actionItems.length > 0) {
        const actionItemsText = data.actionItems
          .map((item: any) => `- ${item.text}${item.completed ? ' (completed)' : ''}`)
          .join('\n')
        contextSections.push(`ACTION ITEMS:\n${actionItemsText}`)
      }

      // Add Q&A section if provided
      if (data.questionHistory && data.questionHistory.length > 0) {
        const qaText = data.questionHistory
          .slice(-5) // Include last 5 Q&A pairs
          .map((qa: any) => `Q: ${qa.question}\nA: ${qa.answer}`)
          .join('\n\n')
        contextSections.push(`QUESTIONS & ANSWERS:\n${qaText}`)
      }

      // Add followup information if provided
      const followupSections: string[] = []
      if (data.followupQuestions && data.followupQuestions.length > 0) {
        followupSections.push(`Suggested Questions:\n${data.followupQuestions.map((q: string) => `- ${q}`).join('\n')}`)
      }
      if (data.followupRisks && data.followupRisks.length > 0) {
        followupSections.push(`Identified Risks:\n${data.followupRisks.map((r: string) => `- ${r}`).join('\n')}`)
      }
      if (data.followupComments && data.followupComments.length > 0) {
        followupSections.push(`AI Comments:\n${data.followupComments.map((c: string) => `- ${c}`).join('\n')}`)
      }
      
      if (followupSections.length > 0) {
        contextSections.push(`FOLLOW-UP INSIGHTS:\n${followupSections.join('\n\n')}`)
      }

      const contextText = contextSections.join('\n\n')

      let prompt = ''
      
      if (type === 'slack') {
        prompt = `You are an AI assistant helping to create a Slack message about a meeting. Please generate a professional Slack message based on the following information:

${contextText}

Please create a well-formatted Slack message that:
- Is professional yet conversational for team communication
- Highlights key points and outcomes
- Includes action items if any
- References important Q&A points if available
- Mentions follow-up insights or risks if relevant
- Uses appropriate Slack formatting (bold for emphasis, bullet points for lists)
- Is concise but informative (aim for under 500 words)
- Suitable for posting in a team channel

Generate only the message content in rich text format, no additional explanations.`
      } else {
        prompt = `You are an AI assistant helping to create an email about a meeting. Please generate a professional email based on the following information:

${contextText}

Please create a well-formatted email message that:
- Has a professional tone suitable for business communication
- Includes a clear structure with paragraphs
- Highlights key points and outcomes
- Includes action items if any
- References important Q&A discussions if available
- Mentions follow-up insights, risks, or suggestions if relevant
- Uses appropriate formatting for email (headings, bullet points)
- Is comprehensive but well-organized
- Suitable for sending to stakeholders or team members

Generate only the email body content in rich text format, no subject line or additional explanations.`
      }

      const result = await this.makeGeminiRequest(prompt, model)
      
      if (!result.success || !result.content) {
        return { success: false, error: result.error || 'Failed to generate message' }
      }

      return { success: true, message: result.content.trim() }
    } catch (error) {
      return { success: false, error: `Message generation failed: ${error instanceof Error ? error.message : 'Unknown error'}` }
    }
  }

  async generateFollowupQuestions(options: FollowupQuestionsOptions): Promise<FollowupQuestionsResult> {
    try {
      const transcriptText = options.transcript
        .map(line => `[${line.time}] ${line.text}`)
        .join('\n')

      const prompt = `You are an AI assistant analyzing an ongoing meeting. Based on the current transcript and context, please generate followup questions, identify potential risks, and provide helpful comments.

MEETING CONTEXT:
Title: ${options.title || 'Meeting'}
Context: ${options.context || 'No specific context'}
Description: ${options.description || 'No description'}

CURRENT TRANSCRIPT:
${transcriptText}

NOTES:
${options.notes || 'No notes'}

SUMMARY SO FAR:
${options.summary || 'No summary yet'}

Please provide your response in the following JSON format:
{
  "questions": [
    "What specific question should be asked to clarify a point?",
    "What details need more elaboration?"
  ],
  "risks": [
    "What potential issues or concerns were identified?",
    "What problems might arise from the current discussion?"
  ],
  "comments": [
    "What important observations about the meeting flow?",
    "What suggestions for improving the discussion?"
  ]
}

Guidelines:
- Questions: Generate 2-4 relevant followup questions that would help clarify or expand on the current discussion
- Risks: Identify 1-3 potential issues, concerns, or problems mentioned or implied in the discussion
- Comments: Provide 1-3 helpful observations or suggestions about the meeting progress
- Make suggestions actionable and specific to the current context
- If no relevant items exist for a category, provide an empty array
- Ensure the JSON is properly formatted`

      const result = await this.makeGeminiRequest(prompt)
      
      if (!result.success || !result.content) {
        return { success: false, error: result.error || 'Failed to generate followup questions' }
      }

      try {
        const jsonMatch = result.content.match(/\{[\s\S]*\}/)
        if (!jsonMatch) {
          return { success: false, error: 'No valid JSON found in Gemini response' }
        }

        const parsedData = JSON.parse(jsonMatch[0])
        
        return {
          success: true,
          data: {
            questions: Array.isArray(parsedData.questions) ? parsedData.questions : [],
            risks: Array.isArray(parsedData.risks) ? parsedData.risks : [],
            comments: Array.isArray(parsedData.comments) ? parsedData.comments : []
          }
        }
      } catch (parseError) {
        return { success: false, error: `Failed to parse Gemini response: ${parseError instanceof Error ? parseError.message : 'Unknown error'}` }
      }
    } catch (error) {
      return { success: false, error: `Followup questions generation failed: ${error instanceof Error ? error.message : 'Unknown error'}` }
    }
  }

  async askQuestion(options: AskQuestionOptions): Promise<AskQuestionResult> {
    try {
      const transcriptText = options.transcript
        .map(line => `[${line.time}] ${line.text}`)
        .join('\n')

      const prompt = `You are an AI assistant with access to a meeting's complete information. Please answer the user's question based on the available data.

MEETING CONTEXT:
Title: ${options.title || 'Meeting'}
Description: ${options.description || 'No description'}
Context: ${options.context || 'No specific context'}

TRANSCRIPT:
${transcriptText}

NOTES:
${options.notes || 'No notes'}

SUMMARY:
${options.summary || 'No summary'}

USER QUESTION:
${options.question}

Please provide a helpful, accurate answer based on the meeting information available. If the information needed to answer the question is not available in the meeting data, please say so clearly. Be specific and reference relevant parts of the transcript when possible.

Respond with only the answer, no additional formatting or explanations.`

      const result = await this.makeGeminiRequest(prompt)
      
      if (!result.success || !result.content) {
        return { success: false, error: result.error || 'Failed to get answer' }
      }

      return { success: true, answer: result.content.trim() }
    } catch (error) {
      return { success: false, error: `Question answering failed: ${error instanceof Error ? error.message : 'Unknown error'}` }
    }
  }
}

export const geminiService = new GeminiService() 