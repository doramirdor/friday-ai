import { TranscriptLine, ActionItem } from './database'

interface GeminiGenerationOptions {
  transcript: TranscriptLine[]
  globalContext: string
  meetingContext: string
  notes: string
  existingTitle: string
}

interface GeminiGenerationResult {
  success: boolean
  data?: {
    summary: string
    actionItems: ActionItem[]
    description: string
    tags: string[]
  }
  error?: string
}

class GeminiService {
  private apiKey: string | null = null

  setApiKey(apiKey: string): void {
    this.apiKey = apiKey || process.env.GEMINI_API_KEY || null
  }

  private async makeGeminiRequest(prompt: string): Promise<{ success: boolean; content?: string; error?: string }> {
    if (!this.apiKey) {
      return { success: false, error: 'Gemini API key not configured' }
    }

    try {
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [
            {
              parts: [
                {
                  text: prompt
                }
              ]
            }
          ],
          generationConfig: {
            temperature: 0.3,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 2048,
          }
        })
      })

      if (!response.ok) {
        const errorData = await response.text()
        return { success: false, error: `Gemini API error: ${response.status} - ${errorData}` }
      }

      const data = await response.json()
      
      if (data.candidates && data.candidates.length > 0 && data.candidates[0].content) {
        const content = data.candidates[0].content.parts[0].text
        return { success: true, content }
      } else {
        return { success: false, error: 'No content generated by Gemini' }
      }
    } catch (error) {
      return { success: false, error: `Network error: ${error instanceof Error ? error.message : 'Unknown error'}` }
    }
  }

  async generateMeetingContent(options: GeminiGenerationOptions): Promise<GeminiGenerationResult> {
    try {
      // Prepare transcript text
      const transcriptText = options.transcript
        .map(line => `[${line.time}] ${line.text}`)
        .join('\n')

      const prompt = `You are an AI assistant helping to analyze a meeting recording. Please generate a comprehensive analysis based on the following information:

MEETING CONTEXT:
Title: ${options.existingTitle}
Global Context: ${options.globalContext}
Meeting-Specific Context: ${options.meetingContext}

TRANSCRIPT:
${transcriptText}

NOTES:
${options.notes}

Please provide your response in the following JSON format (ensure it's valid JSON with escaped quotes):
{
  "summary": "A concise 2-3 sentence summary of the meeting's main points and outcomes",
  "description": "A more detailed description of what was discussed and accomplished (2-3 paragraphs)",
  "actionItems": [
    {
      "id": 1,
      "text": "Action item description",
      "completed": false
    }
  ],
  "tags": ["tag1", "tag2", "tag3"]
}

Guidelines:
- Summary: Keep it concise but capture the essence of the meeting
- Description: Provide context about the meeting type, participants, and key discussions
- Action Items: Extract clear, actionable tasks mentioned or implied in the discussion
- Tags: Generate 3-5 relevant tags for categorization (lowercase, single words or short phrases)
- Ensure the JSON is properly formatted and escaped`

      const result = await this.makeGeminiRequest(prompt)
      
      if (!result.success || !result.content) {
        return { success: false, error: result.error || 'Failed to generate content' }
      }

      try {
        // Try to extract JSON from the response
        const jsonMatch = result.content.match(/\{[\s\S]*\}/)
        if (!jsonMatch) {
          return { success: false, error: 'No valid JSON found in Gemini response' }
        }

        const parsedData = JSON.parse(jsonMatch[0])
        
        // Validate the structure
        if (!parsedData.summary || !parsedData.description || !parsedData.actionItems || !parsedData.tags) {
          return { success: false, error: 'Invalid response structure from Gemini' }
        }

        // Ensure action items have proper IDs
        const actionItems: ActionItem[] = parsedData.actionItems.map((item: any, index: number) => ({
          id: item.id || Date.now() + index,
          text: item.text || '',
          completed: item.completed || false
        }))

        return {
          success: true,
          data: {
            summary: parsedData.summary,
            description: parsedData.description,
            actionItems,
            tags: Array.isArray(parsedData.tags) ? parsedData.tags : []
          }
        }
      } catch (parseError) {
        return { success: false, error: `Failed to parse Gemini response: ${parseError instanceof Error ? parseError.message : 'Unknown error'}` }
      }
    } catch (error) {
      return { success: false, error: `Generation failed: ${error instanceof Error ? error.message : 'Unknown error'}` }
    }
  }

  async generateSummaryOnly(options: GeminiGenerationOptions): Promise<{ success: boolean; summary?: string; error?: string }> {
    try {
      const transcriptText = options.transcript
        .map(line => `[${line.time}] ${line.text}`)
        .join('\n')

      const prompt = `Please provide a concise 2-3 sentence summary of this meeting:

CONTEXT: ${options.globalContext}
MEETING CONTEXT: ${options.meetingContext}
TRANSCRIPT:
${transcriptText}
NOTES:
${options.notes}

Please respond with only the summary, no additional formatting or explanations.`

      const result = await this.makeGeminiRequest(prompt)
      
      if (!result.success || !result.content) {
        return { success: false, error: result.error || 'Failed to generate summary' }
      }

      return { success: true, summary: result.content.trim() }
    } catch (error) {
      return { success: false, error: `Summary generation failed: ${error instanceof Error ? error.message : 'Unknown error'}` }
    }
  }
}

export const geminiService = new GeminiService() 