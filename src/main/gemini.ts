import { TranscriptLine, ActionItem } from './database'

interface GeminiGenerationOptions {
  transcript: TranscriptLine[]
  globalContext: string
  meetingContext: string
  notes: string
  existingTitle: string
}

interface GeminiGenerationResult {
  success: boolean
  data?: {
    summary: string
    actionItems: ActionItem[]
    description: string
    tags: string[]
  }
  error?: string
}

interface GeminiMessageOptions {
  type: 'slack' | 'email'
  data: {
    globalContext: string
    meetingContext: string
    title?: string
    description?: string
    notes?: string
    summary?: string
    transcript?: string
  }
  model?: string
}

class GeminiService {
  private apiKey: string | null = null

  setApiKey(apiKey: string): void {
    this.apiKey = apiKey || process.env.GEMINI_API_KEY || null
  }

  private async makeGeminiRequest(prompt: string, model: string = 'gemini-2.5-pro-preview-06-05'): Promise<{ success: boolean; content?: string; error?: string }> {
    if (!this.apiKey) {
      return { success: false, error: 'Gemini API key not configured' }
    }

    try {
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [
            {
              parts: [
                {
                  text: prompt
                }
              ]
            }
          ],
          generationConfig: {
            temperature: 0.3,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 2048,
          }
        })
      })

      if (!response.ok) {
        const errorData = await response.text()
        return { success: false, error: `Gemini API error: ${response.status} - ${errorData}` }
      }

      const data = await response.json()
      
      if (data.candidates && data.candidates.length > 0 && data.candidates[0].content) {
        const content = data.candidates[0].content.parts[0].text
        return { success: true, content }
      } else {
        return { success: false, error: 'No content generated by Gemini' }
      }
    } catch (error) {
      return { success: false, error: `Network error: ${error instanceof Error ? error.message : 'Unknown error'}` }
    }
  }

  async generateMeetingContent(options: GeminiGenerationOptions): Promise<GeminiGenerationResult> {
    try {
      // Prepare transcript text
      const transcriptText = options.transcript
        .map(line => `[${line.time}] ${line.text}`)
        .join('\n')

      const prompt = `You are an AI assistant helping to analyze a meeting recording. Please generate a comprehensive analysis based on the following information:

MEETING CONTEXT:
Title: ${options.existingTitle}
Global Context: ${options.globalContext}
Meeting-Specific Context: ${options.meetingContext}

TRANSCRIPT:
${transcriptText}

NOTES:
${options.notes}

Please provide your response in the following JSON format (ensure it's valid JSON with escaped quotes):
{
  "summary": "A concise 2-3 sentence summary of the meeting's main points and outcomes",
  "description": "A more detailed description of what was discussed and accomplished (2-3 paragraphs)",
  "actionItems": [
    {
      "id": 1,
      "text": "Action item description",
      "completed": false
    }
  ],
  "tags": ["tag1", "tag2", "tag3"]
}

Guidelines:
- Summary: Keep it concise but capture the essence of the meeting
- Description: Provide context about the meeting type, participants, and key discussions
- Action Items: Extract clear, actionable tasks mentioned or implied in the discussion
- Tags: Generate 3-5 relevant tags for categorization (lowercase, single words or short phrases)
- Ensure the JSON is properly formatted and escaped`

      const result = await this.makeGeminiRequest(prompt)
      
      if (!result.success || !result.content) {
        return { success: false, error: result.error || 'Failed to generate content' }
      }

      try {
        // Try to extract JSON from the response
        const jsonMatch = result.content.match(/\{[\s\S]*\}/)
        if (!jsonMatch) {
          return { success: false, error: 'No valid JSON found in Gemini response' }
        }

        const parsedData = JSON.parse(jsonMatch[0])
        
        // Validate the structure
        if (!parsedData.summary || !parsedData.description || !parsedData.actionItems || !parsedData.tags) {
          return { success: false, error: 'Invalid response structure from Gemini' }
        }

        // Ensure action items have proper IDs
        const actionItems: ActionItem[] = parsedData.actionItems.map((item: any, index: number) => ({
          id: item.id || Date.now() + index,
          text: item.text || '',
          completed: item.completed || false
        }))

        return {
          success: true,
          data: {
            summary: parsedData.summary,
            description: parsedData.description,
            actionItems,
            tags: Array.isArray(parsedData.tags) ? parsedData.tags : []
          }
        }
      } catch (parseError) {
        return { success: false, error: `Failed to parse Gemini response: ${parseError instanceof Error ? parseError.message : 'Unknown error'}` }
      }
    } catch (error) {
      return { success: false, error: `Generation failed: ${error instanceof Error ? error.message : 'Unknown error'}` }
    }
  }

  async generateSummaryOnly(options: GeminiGenerationOptions): Promise<{ success: boolean; summary?: string; error?: string }> {
    try {
      const transcriptText = options.transcript
        .map(line => `[${line.time}] ${line.text}`)
        .join('\n')

      const prompt = `Please provide a concise 2-3 sentence summary of this meeting:

CONTEXT: ${options.globalContext}
MEETING CONTEXT: ${options.meetingContext}
TRANSCRIPT:
${transcriptText}
NOTES:
${options.notes}

Please respond with only the summary, no additional formatting or explanations.`

      const result = await this.makeGeminiRequest(prompt)
      
      if (!result.success || !result.content) {
        return { success: false, error: result.error || 'Failed to generate summary' }
      }

      return { success: true, summary: result.content.trim() }
    } catch (error) {
      return { success: false, error: `Summary generation failed: ${error instanceof Error ? error.message : 'Unknown error'}` }
    }
  }

  async generateMessage(options: GeminiMessageOptions): Promise<{ success: boolean; message?: string; error?: string }> {
    try {
      const { type, data } = options
      const model = options.model || 'gemini-2.5-pro-preview-06-05'

      // Build the context sections that are provided
      const contextSections: string[] = []
      
      if (data.globalContext) {
        contextSections.push(`GLOBAL CONTEXT:\n${data.globalContext}`)
      }
      
      if (data.meetingContext) {
        contextSections.push(`MEETING CONTEXT:\n${data.meetingContext}`)
      }
      
      if (data.title) {
        contextSections.push(`TITLE:\n${data.title}`)
      }
      
      if (data.description) {
        contextSections.push(`DESCRIPTION:\n${data.description}`)
      }
      
      if (data.summary) {
        contextSections.push(`SUMMARY:\n${data.summary}`)
      }
      
      if (data.notes) {
        contextSections.push(`NOTES:\n${data.notes}`)
      }
      
      if (data.transcript) {
        contextSections.push(`TRANSCRIPT:\n${data.transcript}`)
      }

      const contextText = contextSections.join('\n\n')

      let prompt = ''
      
      if (type === 'slack') {
        prompt = `You are an AI assistant helping to create a Slack message about a meeting. Please generate a professional Slack message based on the following information:

${contextText}

Please create a well-formatted Slack message that:
- Is professional yet conversational for team communication
- Highlights key points and outcomes
- Includes action items if any
- Uses appropriate Slack formatting (bold for emphasis, bullet points for lists)
- Is concise but informative
- Suitable for posting in a team channel

Generate only the message content in rich text format, no additional explanations.`
      } else {
        prompt = `You are an AI assistant helping to create an email about a meeting. Please generate a professional email based on the following information:

${contextText}

Please create a well-formatted email message that:
- Has a professional tone suitable for business communication
- Includes a clear structure with paragraphs
- Highlights key points and outcomes
- Includes action items if any
- Uses appropriate formatting for email (headings, bullet points)
- Is comprehensive but well-organized
- Suitable for sending to stakeholders or team members

Generate only the email body content in rich text format, no subject line or additional explanations.`
      }

      const result = await this.makeGeminiRequest(prompt, model)
      
      if (!result.success || !result.content) {
        return { success: false, error: result.error || 'Failed to generate message' }
      }

      return { success: true, message: result.content.trim() }
    } catch (error) {
      return { success: false, error: `Message generation failed: ${error instanceof Error ? error.message : 'Unknown error'}` }
    }
  }
}

export const geminiService = new GeminiService() 